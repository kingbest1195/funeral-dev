### **Финальный план оптимизации производительности**

**Цель:** Устранить оставшиеся замечания в отчёте PageSpeed Insights и достичь стабильного показателя производительности 90+.

---

#### **1. Устранение ресурсов, блокирующих рендеринг (Высший приоритет)**

Это главная оставшаяся проблема, которая мешает быстрой первой отрисовке страницы (FCP).

- **Проблема:** Отчёт по-прежнему указывает на "Eliminate render-blocking resources". Это означает, что браузер вынужден сначала загрузить и обработать все CSS-файлы, прежде чем начать показывать страницу, что вызывает задержку.
- **Решение:** Проверить стратегию **"Критического CSS" (Critical CSS)**.

  1.  **Действие:** AI-агент должен идентифицировать CSS-правила, которые необходимы **только для отрисовки видимой части первого экрана** (шапка, hero-секция).
  2.  **Действие:** Установить Vite-плагин, который автоматизирует этот процесс, например `vite-plugin-critical`.
      ```bash
      npm install vite-plugin-critical --save-dev
      ```
  3.  **Действие:** Настроить `vite.config.js` для использования плагина. Плагин извлечет критические стили и встроит их прямо в `<head>` вашего `index.html`.

      ```javascript
      // vite.config.js
      import { defineConfig } from "vite";
      import react from "@vitejs/plugin-react";
      import { createHtmlPlugin } from "vite-plugin-html";
      import { VitePluginCritical } from "vite-plugin-critical";

      export default defineConfig({
        plugins: [
          react(),
          VitePluginCritical({
            criticalBase: "./dist",
            criticalPages: [{ uri: "index.html", template: "index" }],
          }),
          // ... другие плагины
        ],
      });
      ```

  4.  **Действие:** Остальные, некритичные CSS-стили (для подвала, модальных окон, нижних секций) будут загружаться асинхронно, не блокируя отрисовку.

---

#### **2. Финальная оптимизация изображений (в @/components/YandexMap) **

- **Проблема:** Отчёт всё ещё указывает на необходимость использования современных форматов (`.webp`) для некоторых изображений, в частности, для иконок и, возможно, для фоновых изображений, заданных в CSS.
- **Решение:**
  1.  **Аудит всех изображений:** AI-агент должен провести аудит **всех** изображений в проекте, включая иконки в формате `.png` и фоновые изображения, указанные в `.scss` файлах.
  2.  **Конвертация в WebP:** Все оставшиеся `.png` и `.jpg` файлы необходимо конвертировать в `.webp`.
  3.  **Реализация для фоновых изображений в CSS:** Для фонов, заданных в CSS, нельзя использовать тег `<picture>`. В этом случае нужно либо положиться на то, что большинство современных браузеров поддерживают WebP, либо использовать JS для определения поддержки и добавления соответствующего класса к `<body>`.

---

#### **3. Сокращение неиспользуемого JavaScript**

- **Проблема:** Отчёт указывает на "Reduce unused JavaScript", что может быть связано с "тяжелыми" библиотеками или неоптимальным импортом (особенно в @/components/YandexMap)
- **Решение:**

  1.  **Динамический импорт (Code Splitting):** AI-агент должен проанализировать компоненты, которые не видны сразу при загрузке страницы. В первую очередь, это **квиз-калькулятор (`QuizCalculator.jsx`)** и **модуль карты яндекс (`YandexMap.jsx`)** и **модуль отзывов (`ReviewsWidget.jsx`)**.
  2.  **Действие:** Вместо обычного импорта , использовать динамический импорт `React.lazy`. Это создаст отдельный JS-файл (чанк) для квиза, который будет загружаться только тогда, когда пользователь нажмет на кнопку "Рассчитать" или увидит элемент. Пример:
      ```jsx
      // В HomePage.jsx
      import React, { useState, Suspense } from 'react';

          // Динамический импорт компонента квиза
          const QuizCalculator = React.lazy(() => import('@/components/QuizCalculator/QuizCalculator'));

          const HomePage = () => {
            const [isQuizOpen, setIsQuizOpen] = useState(false);

            return (
              <>
                {/* Кнопка, которая открывает квиз */}
                <button onClick={() => setIsQuizOpen(true)}>Рассчитать стоимость</button>

                {isQuizOpen && (
                  <Suspense fallback={<div>Загрузка...</div>}>
                    <QuizCalculator onClose={() => setIsQuizOpen(false)} />
                  </Suspense>
                )}
              </>
            );
          };
          ```

      <!-- end list -->

  - **Преимущества:** Это значительно уменьшит размер первоначального JS-бандла, что напрямую улучшит метрику TTI (Time to Interactive).

Выполнение этих трех ключевых шагов — внедрение критического CSS, финальная оптимизация всех изображений до WebP и разделение кода для тяжелых JS модулей — гарантированно устранит оставшиеся замечания PageSpeed и позволит достичь целевого показателя 90+.
