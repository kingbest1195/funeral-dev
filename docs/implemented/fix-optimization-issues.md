### **План оптимизации производительности сайта**

**Цель:** Достичь показателя производительности 90+ в Google PageSpeed Insights путём устранения узких мест, указанных в отчёте.

---

#### **1. Оптимизация изображений (Наивысший приоритет)**

Это самая важная задача, которая даст наибольший прирост производительности.

- **1.1. Современные форматы изображений**

  - **Проблема:** В отчёте указано "Используйте современные форматы изображений". В проекте используются форматы `.jpg` и `.png`, которые значительно больше по размеру, чем `.webp`.

  - **Решение:**

    1.  AI-агент должен взять все изображения из папки `src/assets/images` (особенно из `transport-and-office`).
    2.  Конвертировать каждое изображение в формат **WebP** с качеством сжатия `80-85%`. Это уменьшит их размер на 50-70% без видимой потери качества.
    3.  В React-компонентах, где используются эти изображения, внедрить тег `<picture>` для обратной совместимости. Это позволит современным браузерам загружать `.webp`, а старым — `.jpg`/`.png`.

    **Пример реализации для компонента:**

    ```jsx
    import myImageJpg from "./path/to/image.jpg";
    import myImageWebp from "./path/to/image.webp";

    const ImageComponent = () => (
      <picture>
        <source srcSet={myImageWebp} type="image/webp" />
        <source srcSet={myImageJpg} type="image/jpeg" />
        <img src={myImageJpg} alt="Важное описание для SEO" loading="lazy" />
      </picture>
    );
    ```

- **1.2. Правильный размер изображений**

  - **Проблема:** Отчёт указывает "Настройте правильный размер изображений". Это значит, что изображения загружаются в слишком большом разрешении для того места, где они отображаются.
  - **Решение:**
    1.  Определить максимальный размер контейнера, в котором отображается каждое изображение на сайте (например, для фото транспорта это может быть `500px` в ширину).
    2.  Создать версии изображений с этим максимальным размером. Не нужно загружать фото разрешением 4000px, если оно отображается в контейнере шириной 500px.
    3.  Использовать атрибут `srcSet` у тега `<img>` или `<source>`, чтобы браузер мог сам выбрать наиболее подходящий размер изображения в зависимости от разрешения экрана.

- **1.3. Отложенная загрузка (Lazy Loading)**

  - **Проблема:** Загружаются все изображения сразу, включая те, которые находятся внизу страницы и не видны пользователю.
  - **Решение:** Для всех изображений, которые не видны на первом экране (т.е. для всех, кроме hero-секции), добавить атрибут `loading="lazy"`. Это стандартная и очень эффективная техника.
    ```jsx
    <img src="..." alt="..." loading="lazy" />
    ```

---

#### **2. Оптимизация CSS и JavaScript (Высокий приоритет)**

- **2.1. Удаление неиспользуемого CSS/JS**

  - **Проблема:** В отчёте есть пункт "Удалите неиспользуемый код CSS" и "Удалите неиспользуемый код JavaScript". Это означает, что на странице загружаются стили и скрипты, которые не применяются.
  - **Решение:**
    1.  **CSS:** Использовать инструмент `PurgeCSS`. Его можно встроить в процесс сборки Vite. Он проанализирует все `jsx` и `html` файлы и удалит из итогового CSS-бандла все классы, которые не используются.
    2.  **JS:** Провести аудит зависимостей в `package.json`. Если есть библиотеки, которые были установлены, но не импортируются и не используются ни в одном файле, — удалить их.

- **2.2. Устранение ресурсов, блокирующих рендеринг**

  - **Проблема:** CSS-файлы и некоторые JS-скрипты могут блокировать отрисовку страницы, пока они полностью не загрузятся.
  - **Решение:**
    1.  **JS:** Убедиться, что тег `<script>` в `index.html`, который подключает основной бандл, имеет атрибут `type="module"`, что уже подразумевает отложенное исполнение (`defer`). Это стандарт для Vite и, скорее всего, уже сделано.
    2.  **CSS:** Для некритичных CSS (например, стили для модальных окон, которые не видны сразу) можно использовать асинхронную загрузку.
        ```html
        <link
          rel="stylesheet"
          href="/path/to/non-critical.css"
          media="print"
          onload="this.media='all'"
        />
        ```
    3.  **Критические CSS (Critical CSS):** Для максимальной производительности можно выделить стили, необходимые для отрисовки первого экрана, и встроить их прямо в `<head>` в `index.html`. Остальные стили подгружать асинхронно. Для этого существуют Vite-плагины, например, `vite-plugin-critical`.

---

#### **3. Оптимизация кода и ресурсов**

- **3.1. Минимизация кода (HTML, CSS, JS)**

  - **Проблема:** Файлы могут содержать лишние пробелы, комментарии и длинные имена переменных.
  - **Решение:** Убедиться, что в `vite.config.js` для production-сборки включена минимизация. Vite делает это по умолчанию, но стоит проверить, что эта опция не отключена.

- **3.2. Шрифты**

  - **Проблема:** Шрифты могут загружаться неоптимально, блокируя отрисовку текста.
  - **Решение:**
    1.  В `src/styles/fonts.scss` (или где подключаются `@font-face`) добавить свойство `font-display: swap;`. Это позволит браузеру сначала показать текст системным шрифтом, а после загрузки вашего кастомного шрифта — заменить его. Это кардинально улучшает показатель FCP (First Contentful Paint).
        ```css
        @font-face {
          font-family: "SangBleu Sunrise";
          src: url("../assets/fonts/SangBleuSunrise-Regular.woff2") format("woff2");
          font-weight: 400;
          font-style: normal;
          font-display: swap; /* Вот это свойство */
        }
        ```
    2.  Убедиться, что используются только форматы `.woff2`, так как они самые современные и легковесные.

Выполнение этого плана, особенно пунктов по оптимизации изображений, гарантированно поднимет оценку в PageSpeed Insights **выше 90 баллов**.
